import os
import sys
import time
from typing import Optional, Tuple

NGINX_SITES_DIR = "/app/nginx-sites"
NGINX_HTTP_FALLBACK_CONF = "00-front-web-http-fallback.conf"
NGINX_HTTPS_CONF = "10-front-web-https.conf"
LE_LIVE_DIR = "/etc/letsencrypt/live"


def _first_existing_file(paths) -> Optional[str]:
    for p in paths:
        if os.path.isfile(p) and os.path.getsize(p) > 0:
            return p
    return None


def _read_text_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def load_configs() -> Tuple[list, str, str, str]:
    """Return (domains, proxy_pass, domain_path, proxy_path). Exits on error."""
    # In docker-compose we intend to mount ./app -> /app/app.
    # But keep compatibility with older layouts by probing multiple locations.
    domain_candidates = [
        "/app/app/domain.list",
        "/app/domain.list",
        os.path.join(os.getcwd(), "app", "domain.list"),
        os.path.join(os.getcwd(), "domain.list"),
    ]
    proxy_candidates = [
        "/app/app/proxy_pass",
        "/app/proxy_pass",
        os.path.join(os.getcwd(), "app", "proxy_pass"),
        os.path.join(os.getcwd(), "proxy_pass"),
    ]

    domain_path = _first_existing_file(domain_candidates)
    proxy_path = _first_existing_file(proxy_candidates)

    if not domain_path:
        print(
            "ERROR: domain.list not found or empty. Expected one of: "
            + ", ".join(domain_candidates),
            file=sys.stderr,
        )
        sys.exit(1)

    if not proxy_path:
        print(
            "ERROR: proxy_pass not found or empty. Expected one of: "
            + ", ".join(proxy_candidates),
            file=sys.stderr,
        )
        sys.exit(1)

    raw_domains = _read_text_file(domain_path).splitlines()
    domains = []
    for line in raw_domains:
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        domains.append(s)

    if not domains:
        print(f"ERROR: {domain_path} contains no valid domains", file=sys.stderr)
        sys.exit(1)

    proxy_pass = ""
    for line in _read_text_file(proxy_path).splitlines():
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        proxy_pass = s
        break

    if not proxy_pass:
        print(f"ERROR: {proxy_path} contains no valid proxy_pass line", file=sys.stderr)
        sys.exit(1)

    return domains, proxy_pass, domain_path, proxy_path


def write_nginx_vhosts(domains: list, proxy_pass: str) -> None:
    """Write nginx vhosts into /app/nginx-sites.

    - For apex domains that already have a cert at /etc/letsencrypt/live/<apex>/,
      generate an HTTP redirect server (80) and an HTTPS proxy server (443).
    - For domains without certs yet, generate a single HTTP(80) fallback proxy server.

    This keeps staging/prod cert rollout safe: you can request one cert at a time
    without breaking nginx for other domains.
    """
    os.makedirs(NGINX_SITES_DIR, exist_ok=True)

    # Build groups keyed by apex
    input_set = set(domains)
    groups = {}
    for d in domains:
        apex = d[4:] if d.startswith("www.") else d
        names = []
        if apex in input_set:
            names.append(apex)
        www = f"www.{apex}"
        if www in input_set and www not in names:
            names.append(www)
        # If the user only provided www.* without apex, still include that www name
        if not names and d.startswith("www."):
            names = [d]
        groups[apex] = names

    def has_cert(apex: str) -> bool:
        fullchain = os.path.join(LE_LIVE_DIR, apex, "fullchain.pem")
        privkey = os.path.join(LE_LIVE_DIR, apex, "privkey.pem")
        return os.path.isfile(fullchain) and os.path.isfile(privkey)

    cert_groups = []  # list of (apex, names)
    for apex, names in groups.items():
        if names and has_cert(apex):
            cert_groups.append((apex, names))

    cert_domain_set = set()
    for _, names in cert_groups:
        cert_domain_set.update(names)

    # HTTPS + redirect servers for cert-backed groups
    https_lines = []
    https_lines.append("# generated by front-web controller\n")
    if cert_groups:
        for apex, names in cert_groups:
            server_names = " ".join(names)
            fullchain = os.path.join(LE_LIVE_DIR, apex, "fullchain.pem")
            privkey = os.path.join(LE_LIVE_DIR, apex, "privkey.pem")

            https_lines.append(f"server {{\n    listen 80;\n    server_name {server_names};\n\n    location /.well-known/acme-challenge/ {{\n        root /var/www/certbot;\n    }}\n\n    location / {{\n        return 301 https://$host$request_uri;\n    }}\n}}\n")

            https_lines.append(
                f"server {{\n    listen 443 ssl;\n    server_name {server_names};\n    server_tokens off;\n\n    ssl_certificate {fullchain};\n    ssl_certificate_key {privkey};\n\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header X-Frame-Options \"DENY\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n\n    location / {{\n        proxy_pass {proxy_pass};\n        proxy_read_timeout    90;\n        proxy_connect_timeout 90;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_http_version 1.1;\n    }}\n}}\n"
            )
    else:
        https_lines.append("# no certificates found yet under /etc/letsencrypt/live\n")

    https_path = os.path.join(NGINX_SITES_DIR, NGINX_HTTPS_CONF)
    https_tmp = https_path + ".tmp"
    with open(https_tmp, "w", encoding="utf-8") as f:
        f.write("\n".join(https_lines))
    os.replace(https_tmp, https_path)

    # HTTP fallback proxy for domains without certs yet
    fallback_domains = [d for d in domains if d not in cert_domain_set]
    fb_lines = []
    fb_lines.append("# generated by front-web controller\n")
    if fallback_domains:
        fb_server_names = " ".join(fallback_domains)
        fb_lines.append(
            f"server {{\n    listen 80;\n    server_name {fb_server_names};\n\n    location /.well-known/acme-challenge/ {{\n        root /var/www/certbot;\n    }}\n\n    location / {{\n        proxy_pass {proxy_pass};\n        proxy_read_timeout    90;\n        proxy_connect_timeout 90;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_http_version 1.1;\n    }}\n}}\n"
        )
    else:
        fb_lines.append("# all domains have certs; no http fallback needed\n")

    fb_path = os.path.join(NGINX_SITES_DIR, NGINX_HTTP_FALLBACK_CONF)
    fb_tmp = fb_path + ".tmp"
    with open(fb_tmp, "w", encoding="utf-8") as f:
        f.write("\n".join(fb_lines))
    os.replace(fb_tmp, fb_path)


def mtime(path: str) -> float:
    try:
        return os.path.getmtime(path)
    except Exception:
        return 0.0


def main() -> None:
    print("front-web controller starting...", flush=True)

    domains, proxy_pass, domain_path, proxy_path = load_configs()
    last_domain_mtime = mtime(domain_path)
    last_proxy_mtime = mtime(proxy_path)

    print(f"Loaded domain.list from: {domain_path}")
    print(f"Loaded proxy_pass from:  {proxy_path}")
    print(f"Active domains ({len(domains)}): {', '.join(domains)}")
    print(f"proxy_pass: {proxy_pass}")

    write_nginx_vhosts(domains, proxy_pass)
    print("Wrote nginx vhosts to /app/nginx-sites/00-front-web-http-fallback.conf and 10-front-web-https.conf (reload nginx to apply).", flush=True)

    # MVP: just stay alive and re-read configs when they change.
    # (Next steps will generate nginx vhosts and reload nginx.)
    while True:
        time.sleep(5)

        new_domain_mtime = mtime(domain_path)
        new_proxy_mtime = mtime(proxy_path)

        if new_domain_mtime != last_domain_mtime or new_proxy_mtime != last_proxy_mtime:
            try:
                domains, proxy_pass, _, _ = load_configs()
                print("Config changed; reloaded:")
                print(f"  domains ({len(domains)}): {', '.join(domains)}")
                print(f"  proxy_pass: {proxy_pass}")
                write_nginx_vhosts(domains, proxy_pass)
                print("Wrote nginx vhosts to /app/nginx-sites/00-front-web-http-fallback.conf and 10-front-web-https.conf (reload nginx to apply).", flush=True)
                last_domain_mtime = new_domain_mtime
                last_proxy_mtime = new_proxy_mtime
            except SystemExit:
                # Keep running so you can fix files without the container restart-loop.
                print("Config reload failed; keeping last good config. Fix files and save again.")
            except Exception as e:
                print(f"Config reload error: {e!r}")


if __name__ == "__main__":
    main()